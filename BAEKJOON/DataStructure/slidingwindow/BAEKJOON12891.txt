### 백준 12891 문제 : DNA 비밀번호

평소 문자열을 이용해 노는 것을 좋아하는 민호는 DNA 문자열을 알게 됐다.
DNA 문자열은 모든 문자열에 등장하는 문자가 {'A', 'C', 'G', 'T'}인 문자열을 말한다.
예를 들어 "ACKA"는 DNA 문자열이 아니지만, "ACCA"는 DNA 문자열이다.
이런 신비한 문자열에 완전히 매료된 민호는 임의의 DNA 문자열을 만들고 만들어진 DNA 문자열의 부분 문자열을 비밀번호로 사용하기로 마음먹었다.

하지만 민호는 이 방법에는 큰 문제가 있다는 것을 발견했다.
임의의 DNA 문자열의 부분 문자열을 뽑았을 때 "AAAA"와 같이 보안에 취약한 비밀번호가 만들어질 수 있기 때문이다.
그래서 민호는 부분 문자열에서 등장하는 문자의 개수가 특정 개수 이상이어야 비밀번호로 사용할 수 있다는 규칙을 만들었다.
예를 들어 임의의 DNA 문자열이 "AAACCTGCCAA"이고 민호가 뽑을 부분 문자열의 길이가 4라고 가정해 보자.
그리고 부분 문자열에 'A'는 1개 이상, 'C'는 1개 이상, 'G'는 1개 이상, 'T'는 0개 이상 등장해야 비밀번호로 사용할 수 있다고 가정해 보자.
이때 "ACCT"는 'G'가 1개 이상 등장해야 한다는 조건을 만족하지 못해 비밀번호로 사용할 수 없지만, "GCCA"은 모든 조건을 만족하므로 비밀번호로 사용할 수 있다.

민호가 만든 임의의 DNA 문자열과 비밀번호로 사용할 부분 문자열의 길이 그리고 {'A', 'C', 'G', 'T'}가 각각 몇 번 이상 등장해야 비밀번호로 사용할 수 있는지,
순서대로 주어졌을 때 민호가 만들 수 있는 비밀번호의 종류의 수를 구하는 프로그램을 작성하시오.
단, 부분 문자열이 등장하는 위치가 다르면 부분 문자열의 내용이 같더라도 다른 문자열로 취급한다.

## 입력
1번째 줄에 민호가 임의로 만든 DNA 문자열의 길이 |S|와 비밀번호로 사용할 부분 문자열의 길이 |P|가 주어진다.
1 ≤ |P| ≤ |S| ≤ 1,000,000
2번째 줄에 민호가 임의로 만든 DNA 문자열이 주어진다.
3번째 줄에 부분 문자열에 포함돼야 할 {'A', 'C', 'G', 'T'}의 최소 개수가 공백 문자를 사이에 두고 각각 주어진다.
각각의 수는 |S|보다 작거나 같은 음이 아닌 정수로 총합은 |S|보다 작거나 같다는 것이 보장된다.

## 출력
첫 번째 줄에 민호가 만들 수 있는 비밀번호의 종류의 수를 출력해라.

## 입출력 예시 (입력 / 출력)
|-----------------------|
|   9 8         |   0   |
|   CCTGGATTG   |       |
|   2 0 1 1     |       |
|-----------------------|
|   4 2         |   2   |
|   GATA        |       |
|   1 0 0 1     |       |
|-----------------------|

-------------------------------------------------------------------

### 문제 분석

풀어보며 느낌을 찾자.
DNA 문자열의 길이 : S = 9
비밀번호로 사용할 부분 문자열의 길이 : P = 8
S = "CCTGGATTG"
A = 2, C = 0, G = 1, T = 1
S의 종류 C : 2, T : 2, A : 1, G : 3

P가 될 수 있는 것
CCTGGATT : A = 1, C = 2, G = 2, T = 3 -> A가 1이므로 불가능
CTGGATTG : A = 1, C = 1, G = 3, T = 3 -> A가 1이므로 불가능

DNA 문자열의 길이 : S = 4
비밀번호로 사용할 부분 문자열의 길이 : P = 2
S = "GATA"
A = 1, C = 0, G = 0, T = 1
S의 종류 : A = 2, C = 0, G = 1, T = 1

P가 될 수 있는 것
GA : A = 1, G = 1 -> T가 없으므로 불가능
AT : A = 1, T = 1 -> 둘 다 만족하므로 가능
TA : T = 1, A = 1 -> 둘 다 만족하므로 가능

* 바로 0개 반환할 수 있는 조건
* DNA 문자열 S 내의 {'A', 'C', 'G', 'T'}가 최소 개수보다 작은게 하나라도 있으면 0 반환

이제 부분 문자열을 만들어야 함.
투 포인트 이용해서 부분 문자열 배열 만들 수 있을 듯
p1 = 0, p2 = p - 1로 잡고 문자열 배열에 넣고
p1, p2를 하나씩 증가 시키면서 배열에 넣으면 될 듯(p2가 S보다 같거나 작을 때까지 반복)
부분 문자열 배열의 크기 : S - P + 1 (e.g., S = 9, P = 8 -> 2)

부분 문자열 배열의 원소 하나하나 최소 값이 들어있는지 확인 하는 작업
charAt으로 문자가 최소 개수를 만족하는지 체크해서
최소 개수를 다 만족하면 count 증가

마지막에 count 반환하면 될 듯

-------------------------------------------------------------------

시간 복잡도 문제로 다시 해보자.

S의 길이 = 4
P의 길이 = 2
S = GATA
A C G T -> 1 0 0 1 

p1 = 0, p2 = 1 (S - P - 1)
GA => A C G T : 1 0 1 0 -> 3 != 4
p1 = 1, p2 = 3
AT => A C G T : 1 0 0 1 -> 4 = 4    -- 1개
TA => A C G T : 1 0 0 1 -> 4 = 4    -- 2개

부분 문자열을 char 배열로 만들고 포인터를 옮길 때마다 새로운 것을 추가하고 기존 꺼를 빼면
될 듯..?

GA -> AT 로 갈 때 G가 빠지고 T가 새롭게 들어옴.
G의 개수와 T의 개수만 바뀜. (G는 -1, T는 +1)
-> p1의 값 빼기, p2의 값 넣기

최소를 만족하는 게 4개가 되면 다 만족하므로 4를 기준으로 4보다 작으면 만족 X, 4이면 만족


-------------------------------------------------------------------

### 수도 코드

S길이, P길이 입력받기

DNA 문자열(S) 입력받기

int 배열 만들어서 {'A', 'C', 'G', 'T'}의 최소 개수 입력 받기

S 내에 포함된 A, C, G, T를 알기 위해 int 변수 0으로 초기화

for (i -> 0 ~ S의 길이 - 1) {
    if (S.charAt(i) == 배열[0]) {
        A++
    } else if (S.charAt(i) == 배열[1]) {
        C++
    } else if (S.charAt(i) == 배열[2]) {
        G++
    } else {
        T++
    }
}

if (A < 배열[0] 혹은 C < 배열[1] 혹은 G < 배열[2] 혹은 T < 배열[3]) {
    0 반환
}

투 포인트 사용을 위해 int 변수 p1, p2를 각각 0, P로 초기화
int k = 0
부분 문자열 배열을 S의 길이 - P의 길이 + 1 로 선언
비밀번호의 종류의 수 int 변수로 선언

while (p2 <= S의 길이 그리고 k < 부분 문자열 배열의 크기) {
    
    부분 문자열 배열[i] = S.substring(p1, p2)
    
    k++
    p1++
    p2++
}

for (i -> 0 ~ 부분 문자열 배열의 크기) {
    A, C, G, T 다 0으로 초기화

    for (j -> 0 ~ 부분 문자열 배열[i]의 크기) {
        if (부분 문자열 배열[i].charAt[j] == 배열[0]) {
            A++
        } else if (부분 문자열 배열[i].charAt[j] == 배열[1]) {
            C++
        } else if (부분 문자열 배열[i].charAt[j] == 배열[2]) {
            G++
        } else {
            T++
        }
    }
    
    if (A >= 배열[0] 그리고 C >= 배열[1] 그리고 G >= 배열[2] 그리고 T >= 배열[3]) {
        비밀번호의 종류의 수++
    }
}

비밀번호의 종류의 수 출력